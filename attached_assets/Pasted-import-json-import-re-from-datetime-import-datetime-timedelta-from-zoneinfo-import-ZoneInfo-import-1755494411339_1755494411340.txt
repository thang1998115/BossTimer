import json
import re
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo

import discord
from discord.ext import commands, tasks

# ====== C·∫§U H√åNH C∆† B·∫¢N ======
TZ = ZoneInfo("Asia/Ho_Chi_Minh")  # m√∫i gi·ªù VN
PREFIX = "!"
DATA_FILE = "data.json"

from keep_alive import keep_alive

keep_alive()  # gi·ªØ Replit lu√¥n "th·ª©c" (s·∫Ω k·∫øt h·ª£p UptimeRobot ·ªü b∆∞·ªõc 4)

# TOKEN: ƒë·∫∑t b·∫±ng Replit Secret (Settings ‚Üí Secrets)
import os

TOKEN = os.getenv("DISCORD_TOKEN")

intents = discord.Intents.default()
intents.message_content = True
bot = commands.Bot(command_prefix=PREFIX, intents=intents)

# ====== DANH S√ÅCH ƒê·ªäA ƒêI·ªÇM ‚Üí TH·ªúI GIAN H·ªíI (PH√öT) + T·ªà L·ªÜ (%) ======
# L∆∞u √Ω: ch·ªâ d√πng ƒë·ªãa ƒëi·ªÉm (English), b·ªè ti·∫øng Trung.
# B·∫°n c√≥ th·ªÉ g√µ alias t·∫Øt, v√≠ d·ª•: antb3, beehive, gorgon, cruma_b6, ...
LOCATIONS = {
    # key :  (Label, respawn_minutes, spawn_rate, [aliases...])
    "repirio": ("Repirio", 7 * 60, 50, ["repirio", "repiro", "repi"]),
    "orfen": ("Orfen", 24 * 60, 33, ["orfen", "or"]),
    "Queen ant/ant_b3": ("Ant Nest (B3)", 6 * 60, 33,
                         ["queenant", "antb3", "ant_nest_b3", "ant3", "b3"]),
    "Gahareth/tanor": ("Tanor Canyon", 9 * 60, 50,
                       ["gahreth", "gah", "tanor", "tanor_canyon", "canyon"]),
    "felis": ("Felis/Bee Hive", 3 * 60, 50,
              ["fe", "fel", "felis", "beehive", "bee", "hive"]),
    "Pan Narod/gorgon":
    ("Pan Narod/Gorgon Flower Garden", 5 * 60, 50,
     ["gorgon", "pannarod", "panna", "narod", "gfg", "flower"]),
    "timiniel": ("Timiniel", 8 * 60, 100, [
        "timiniel",
        "timin",
    ]),
    "Timitris/floran":
    ("Floran Fields", 8 * 60, 100,
     ["floran", "Timitris", "Timit", "flor", "floran_fields"]),
    "Mutated Cruma/cruma_marsh": ("Cruma Marshlands", 8 * 60, 100, [
        "cruma_marsh", "Mutated Cruma", "Mutated", "Muta", "marshlands",
        "marsh"
    ]),
    "Contaminated Cruma/cruma_b3": ("Cruma Tower (B3)", 8 * 60, 100, [
        "cruma_b3", "Contaminated Cruma", "Contaminated", "Contami", "Conta",
        "Cont", "ct_b3", "cruma3"
    ]),
    "Basila/southern_waste":
    ("Southern Wasteland", 4 * 60, 50,
     ["southern", "Basila", "Basil", "Bas", "southern_wasteland", "waste"]),
    "Dragon/antharas_b6": ("Antharas Lair (B6)", 12 * 60, 33,
                           ["antharas_b6", "Dragon", "Dra", "antharas", "b6"]),
    "Core Susceptor/cruma_b7": ("Cruma Tower (B7)", 10 * 60, 33, [
        "cruma_b7", "Core Susceptor", "Core", "Susceptor", "Sus", "ct_b7",
        "cruma7"
    ]),
    "breka": ("Breka's Stronghold", 6 * 60, 50, ["breka", "brekas"]),
    "Talkin/leto":
    ("Leto Lizardman", 8 * 60, 50, ["leto", "Talkin", "Tal", "lizardman"]),
    "Tempest/morgue": ("Morgue", 6 * 60, 50,
                       ["Tempest", "Tem", "Temp", "morgue"]),
    "chertuba": ("Chertuba's Barracks", 6 * 60, 50, ["chertuba", "barracks"]),
    "pillagers": ("Pillagers' Outpost", 6 * 60, 50, ["pillagers", "outpost"]),
    "dion_plains": ("Dion Plains", 6 * 60, 50,
                    ["dion", "plains", "dion_plains"]),
    "giants_vestige": ("Giants' Vestige", 7 * 60, 100, ["giants", "vestige"]),
    "blood_swamp": ("Bloodstained Swampland", 7 * 60, 50,
                    ["bloodstained", "swamp", "blood_swamp"]),
    "ruins_despair": ("Ruins of Despair", 10 * 60, 50,
                      ["despair", "ruins_of_despair"]),
    "rebel_territory": ("Rebel Territory", 10 * 60, 100,
                        ["rebel", "rebel_territory"]),
    "medusa_garden": ("Medusa Garden", 10 * 60, 100,
                      ["medusa", "medusa_garden"]),
    "delu": ("Delu Dwellings", 10 * 60, 100, ["delu", "delu_dwellings"]),
    "cruma_b6": ("Cruma Tower (B6)", 10 * 60, 100,
                 ["cruma_b6", "ct_b6", "cruma6"]),
    "death_pass": ("Death Pass", 12 * 60, 100, ["death", "death_pass"]),
    "dragon_valley_n": ("Dragon Valley (North)", 9 * 60, 100,
                        ["dragon", "dv_north", "dv", "dragon_valley"]),
    "dion_hills": ("Dion Hills", 12 * 60, 100, ["dion_hills", "hills"]),
    "ant_b2": ("Ant Nest (B2)", 12 * 60, 100,
               ["antb2", "ant_nest_b2", "ant2", "b2"]),
    "timak": ("Timak Orc Outpost", 12 * 60, 50,
              ["timak", "orc_outpost", "timak_orc"]),
    "briand": ("Briand Stronghold", 12 * 60, 50, ["briand"])
}


# ====== L∆ØU / T·∫¢I D·ªÆ LI·ªÜU ======
def load_data():
    try:
        with open(DATA_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    except:
        return {"records": []}


def save_data(data):
    with open(DATA_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)


data = load_data()


def find_key_by_alias(word: str):
    w = word.lower()
    for key, (label, _m, _r, aliases) in LOCATIONS.items():
        if w == key or w in aliases:
            return key
    return None


# ====== NHI·ªÜM V·ª§ N·ªÄN: NH·∫ÆC TR∆Ø·ªöC 5' & B√ÅO "SPAWN" ======
@tasks.loop(seconds=30)
async def notifier():
    now = datetime.now(TZ)
    changed = False
    for rec in data["records"]:
        # rec: {key,label,killed_at,respawn_at,channel_id,warned,done}
        if rec.get("done"):
            continue
        respawn_at = datetime.fromisoformat(rec["respawn_at"])
        delta = respawn_at - now

        try:
            channel = bot.get_channel(int(rec["channel_id"]))
        except:
            channel = None

        # Nh·∫Øc tr∆∞·ªõc 5 ph√∫t
        if delta.total_seconds() <= 300 and delta.total_seconds(
        ) > 0 and not rec.get("warned"):
            if channel and hasattr(channel, 'send'):
                await channel.send(
                    f"‚è∞ **{rec['label']}** s·∫Ω xu·∫•t hi·ªán **trong 5 ph√∫t** (h·ªìi l√∫c {respawn_at.strftime('%H:%M')})."
                )
            rec["warned"] = True
            changed = True

        # B√°o ƒë√£ spawn
        if delta.total_seconds() <= 0 and not rec.get("done"):
            if channel and hasattr(channel, 'send'):
                await channel.send(
                    f"‚úÖ **{rec['label']}** **ƒë√£ h·ªìi sinh** (gi·ªù: {respawn_at.strftime('%H:%M')})."
                )
            rec["done"] = True
            changed = True

    if changed:
        save_data(data)


@bot.event
async def on_ready():
    print(f"‚úÖ Logged in as {bot.user}")
    if not notifier.is_running():
        notifier.start()


# ====== NH·∫¨N L·ªÜNH D·∫†NG: "<ƒë·ªãa_ƒëi·ªÉm> <HHMM>" ======
@bot.event
async def on_message(message: discord.Message):
    if message.author.bot:
        return
    content = message.content.strip()

    # b·ªè qua n·∫øu l√† command c√≥ prefix (ƒë·ªÉ commands.* x·ª≠ l√Ω)
    if content.startswith(PREFIX):
        return await bot.process_commands(message)

    m = re.match(r"([a-zA-Z0-9_]+)\s+(\d{4})$", content)
    if not m:
        return  # kh√¥ng ph·∫£i input theo format n√†y

    alias, hhmm = m.group(1), m.group(2)
    key = find_key_by_alias(alias)
    if not key:
        return await message.channel.send(
            f"‚ùå Kh√¥ng t√¨m th·∫•y ƒë·ªãa ƒëi·ªÉm `{alias}`. G√µ `!list` ƒë·ªÉ xem danh s√°ch alias."
        )

    label, respawn_min, rate, _ = LOCATIONS[key]

    # d·ª±ng th·ªùi ƒëi·ªÉm "ch·∫øt" theo HHMM h√¥m nay (n·∫øu ƒë√£ qua th√¨ coi l√† ng√†y mai)
    now = datetime.now(TZ)
    killed_at = now.replace(hour=int(hhmm[:2]),
                            minute=int(hhmm[2:]),
                            second=0,
                            microsecond=0)
    if killed_at > now + timedelta(minutes=1):
        # n·∫øu nh·∫≠p gi·ªù t∆∞∆°ng lai qu√° xa so v·ªõi hi·ªán t·∫°i -> coi l√† c·ªßa h√¥m qua (tr√°nh sai l·ªách)
        killed_at -= timedelta(days=1)

    respawn_at = killed_at + timedelta(minutes=respawn_min)

    # l∆∞u record (m·ªói key ch·ªâ gi·ªØ 1 record m·ªõi nh·∫•t)
    # n·∫øu th√≠ch nhi·ªÅu record / multi-channels th√¨ c√≥ th·ªÉ append thay v√¨ replace
    existing = [r for r in data["records"] if r["key"] == key]
    for r in existing:
        data["records"].remove(r)

    rec = {
        "key": key,
        "label": label,
        "killed_at": killed_at.isoformat(),
        "respawn_at": respawn_at.isoformat(),
        "channel_id": str(message.channel.id),
        "warned": False,
        "done": False,
        "rate": rate
    }
    data["records"].append(rec)
    save_data(data)

    await message.channel.send(
        f"‚ò†Ô∏è **{label}** ch·∫øt l√∫c **{killed_at.strftime('%H:%M')}** ‚Üí "
        f"h·ªìi l√∫c **{respawn_at.strftime('%H:%M')}** (*{respawn_min//60}h, {rate}%*)."
    )

    await bot.process_commands(message)


# ====== L·ªÜNH HI·ªÇN TH·ªä ======
@bot.command(help="Hi·ªán danh s√°ch ƒë√£ ghi & th·ªùi gian c√≤n l·∫°i")
async def boss(ctx: commands.Context):
    if not data["records"]:
        return await ctx.send(
            "üì≠ Ch∆∞a c√≥ d·ªØ li·ªáu. Nh·∫≠p theo m·∫´u: `antb3 1304`, `beehive 0930`, ..."
        )

    now = datetime.now(TZ)
    rows = []
    for r in data["records"]:
        respawn_at = datetime.fromisoformat(r["respawn_at"])
        remain = respawn_at - now
        remain_txt = "ƒë√£ h·ªìi" if remain.total_seconds() <= 0 else \
            (f"{remain.seconds//3600}h{(remain.seconds%3600)//60:02d}m")
        rows.append((respawn_at,
                     f"- **{r['label']}** ‚Üí {respawn_at.strftime('%H:%M')} "
                     f"({remain_txt}) ‚Äî {r['rate']}%"))

    rows.sort(key=lambda x: x[0])
    msg = "**üìú Boss/Location timers:**\n" + "\n".join(r[1] for r in rows)
    await ctx.send(msg)


@bot.command(help="Danh s√°ch ƒë·ªãa ƒëi·ªÉm + alias + th·ªùi gian h·ªìi + t·ªâ l·ªá")
async def list(ctx: commands.Context):
    lines = []
    for key, (label, minutes, rate, aliases) in LOCATIONS.items():
        h = minutes // 60
        lines.append(f"- **{label}** ‚Äî {h}h / {rate}% ‚Äî alias: `{aliases[0]}`")
    await ctx.send("**üìö Location list (g√µ t·∫Øt):**\n" + "\n".join(lines))


@bot.command(help="Xo√° 1 timer theo alias/key, v√≠ d·ª•: !del antb3")
async def del_(ctx: commands.Context, alias: str):
    key = find_key_by_alias(alias)
    if not key:
        return await ctx.send("‚ùå Alias kh√¥ng h·ª£p l·ªá. G√µ `!list` ƒë·ªÉ xem.")
    before = len(data["records"])
    data["records"] = [r for r in data["records"] if r["key"] != key]
    save_data(data)
    await ctx.send("üóëÔ∏è ƒê√£ xo√°." if len(data["records"]) <
                   before else "‚ÑπÔ∏è Kh√¥ng c√≥ record ƒë·ªÉ xo√°.")


@bot.command(help="Xo√° to√†n b·ªô timers (admin d√πng)")
@commands.has_permissions(manage_guild=True)
async def clear(ctx: commands.Context):
    data["records"].clear()
    save_data(data)
    await ctx.send("üßπ ƒê√£ xo√° to√†n b·ªô timers.")


# ====== CH·∫†Y BOT ======
if not TOKEN:
    raise SystemExit("‚ö†Ô∏è Ch∆∞a ƒë·∫∑t DISCORD_TOKEN trong Secrets c·ªßa Replit.")
bot.run(TOKEN)
